\documentclass{sig-alternate-05-2015}
\usepackage[l2tabu,orthodox]{nag}
\usepackage[utf8x]{inputenc}       
\usepackage[british]{babel}        
\usepackage[babel=true]{microtype}
\usepackage{amsmath}
\usepackage[all]{onlyamsmath}
\usepackage{newtxtext}
\usepackage{newtxmath}
\usepackage{upquote}
\usepackage{graphicx}
\usepackage{url}
\usepackage[caption=false]{subfig}
\usepackage{booktabs}
\usepackage{bytefield}
\usepackage{listings}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{color}
\usepackage{balance}

\newcommand{\todo}[1]{\textbf{\textcolor{red}{To do -- #1}}}

%==================================================================================================
% The following information gets written into the PDF file information:
\pdfinfo{
  /Title        (Implementing Real-time Transport Services over an Ossified Network)
  /Author       (Stephen McQuistin, Colin Perkins, and Marwan Fayed)
  /Subject      (Real-time Transport Protocols)
  /Keywords     (Transport Services, TCP, TCP Hollywood)
  /CreationDate (D:20160516000000+01'00')
  /ModDate      (D:20160516000000+01'00')
  /Creator      (LaTeX)
  /Producer     (pdfTeX)
}
%==================================================================================================
\begin{document}
\title{Implementing Real-time Transport Services over an Ossified Network}
\numberofauthors{3}
\author{
  \alignauthor
    Stephen McQuistin\\
    \affaddr{University of Glasgow, UK}\\
    \email{sm@smcquistin.uk}
  \alignauthor
    Colin Perkins\\
    \affaddr{University of Glasgow, UK}\\
    \email{csp@csperkins.org}
  \alignauthor
    Marwan Fayed\\
    \affaddr{University of Stirling, UK}\\
    \email{mmf@cs.stir.ac.uk}
}

\toappear{}
\maketitle
%==================================================================================================
\begin{abstract}

% Four sentences:
%  - State the problem
%  - Say why it's an interesting problem
%  - Say what your solution achieves
%  - Say what follows from your solution



\end{abstract}
%==================================================================================================
\begin{CCSXML}
  <ccs2012>
    <concept>
      <concept_id>10003033.10003039.10003040</concept_id>
      <concept_desc>Networks~Network protocol design</concept_desc>
      <concept_significance>500</concept_significance>
    </concept>
    <concept>
      <concept_id>10003033.10003039.10003048</concept_id>
      <concept_desc>Networks~Transport protocols</concept_desc>
      <concept_significance>500</concept_significance>
    </concept>
  </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Networks~Network protocol design}
\ccsdesc[500]{Networks~Transport protocols}

\printccsdesc

\keywords{Transport protocols; real-time multimedia applications}
%==================================================================================================
\section{Introduction}

% A good paper introduction is fairly formulaic. If you follow a simple set
% of rules, you can write a very good introduction. The following outline can
% be varied. For example, you can use two paragraphs instead of one, or you
% can place more emphasis on one aspect of the intro than another. But in all
% cases, all of the points below need to be covered in an introduction, and
% in most papers, you don't need to cover anything more in an introduction.
%
% Paragraph 1: Motivation. At a high level, what is the problem area you
% are working in and why is it important? It is important to set the larger
% context here. Why is the problem of interest and importance to the larger
% community?

Real-time applications are increasingly important in the Internet. 
We want to make it easier to write these applications, while improving
the quality of experience for users of those applications by lowering
latency and increasing robustness. 
In this, we are challenged by the limitations of the standard Internet 
transport protocols, and by the ossified nature of the network, which makes
it increasingly difficult to deploy new transports. 

% Paragraph 2: What is the specific problem considered in this paper? This
% paragraph narrows down the topic area of the paper. In the first
% paragraph you have established general context and importance. Here you
% establish specific context and background.

In practice, the only protocols that can be widely used in the Internet are
TCP and UDP. Other protocols are blocked by firewalls and other middleboxes.  
TCP provides sophisticated congestion control, coupled with a reliable,
ordered, byte stream API. These are suitable for many applications, but are
not necessarily appropriate for real-time traffic.  UDP exposes the best-effort 
IP packet delivery service, offering flexibility to develop new protocols,
but at the cost of requiring completely new protocol mechanisms to be
defined. Both protocols are usable for real-time applications, but neither
really provides the right services and API.  This forces each application
to re-invent mechanisms that should be provided by the transport, increasing 
costs and complexity, raising barriers to innovation.

% Paragraph 3: "In this paper, we show that...". This is the key paragraph
% in the introduction - you summarize, in one paragraph, what are the main
% contributions of your paper, given the context established in paragraphs 
% 1 and 2. What's the general approach taken? Why are the specific results
% significant? The story is not what you did, but rather:
%  - what you show, new ideas, new insights
%  - why interesting, important?
% State your contributions: these drive the entire paper.  Contributions
% should be refutable claims, not vague generic statements.

In this paper we discuss the appropriate set of transport services and APIs
for real-time applications.
We demonstrate that it is possible to realise these services and APIs
in the context of both TCP and UDP, despite the limitations imposed by the
legacy protocols, middleboxes, and ossification of the network. 
We present initial results to show that, despite the observed ossification,
the network has the flexibility to deploy new transport protocols, if care
is taken to reinterpret layer boundaries and deploy those new transports in
the context of TCP and UDP.

% Paragraph 4: What are the differences between your work, and what others
% have done? Keep this at a high level, as you can refer to future sections
% where specific details and differences will be given, but it is important
% for the reader to know what is new about this work compared to other work
% in the area.

Our contributions are to identify the needs of real-time applications, and
the appropriate transport services and APIs to support those needs; 
to illustrate how those transport services can be realised on the current
Internet, in the context of UDP and TCP deployments; and 
to present some initial measurement results to show that the mechanisms we
propose ought to be usable in the public Internet. 

% Paragraph 5: "We structure the remainder of this paper as follows." Give
% the reader a road-map for the rest of the paper. Try to avoid redundant
% phrasing, "In Section 2, In section 3, ..., In Section 4, ... ", etc.

We begin, in Section \ref{sec:services} by discussing transport services 
for real-time applications, and outlining the common conceptual API that
those applications use. 
This is followed, in Section \ref{sec:ossification}, by a review of the
deployment considerations for new protocols, caused by ossification of
the network, with Section \ref{sec:partial} considering, in particular, how
TCP reliability semantics can evolve within the constraints of the deployed
infrastructure.
Section \ref{sec:realising} outlines how the transport services we have
identified can be realised in practical networks.
Finally, Section \ref{sec:related} discusses related work, and Section
\ref{sec:conclusions} concludes.

%==================================================================================================
\section{Real-time Transport Services}
\label{sec:services}

In the IETF, the Transport Services (TAPS) working group is chartered to 
(1) develop a taxonomy of \emph{transport services}. That is, to identify the
features that comprise, and can be combined, to form complete transport
protocols; and (2) to develop an abstract API for applications to request
desirable services, allowing the system to select an appropriate transport
protocol based on application needs. It is hoped that this will loosen the
coupling between application and transport, so enabling deployment of new 
transport protocols.

The work in TAPS is valuable, because it gives us a vocabulary for
discussing the components of transport protocols.  We can then use that
vocabulary when discussing the needs of real-time applications, and the
protocols needed to support those needs.

The essential feature of real-time applications is clearly timing. That is,
since these applications convey real-time data, they all have some concept
of a \emph{deadline} by which that data must be presented, after which it
becomes useless. 
The deadline might be short or long. Interactive applications, such as
telephony, video conferencing, or telepresence, require low end-to-end
latency, with the deadline for presenting the media (playing the audio,
displaying the video frame) being tens, or perhaps low hundreds, of
milliseconds after it was captured. Non-interactive applications, such as
broadcast TV, may have deadlines in the order of seconds, or even tens of
seconds for on-demand programming. 
The deadlines in many networked multimedia applications are unusual when
compared to other real-time systems. They are simultaneously flexible and
strict: flexible in that the exact value of the deadline is typically not
important, provided it is of the right order-of-magnitude for the
application, but strict in that any particular deadline provides a hard
cut-off, after which the data is useless. 

The presence of deadlines, in a network that offers only a best-effort
packet deliver service, implies that the transport must provide
\emph{partial reliability}.
The network has non-zero probability of losing any particular packet. 
If forward error correction is used to repair loss, this implies there is
always some probability that a particular packet will be non-recoverable.
If retransmission is used to recover from losses, there is the potential 
for unbounded delay, since any retransmission may itself be lost. 
These probabilities can be estimated, to give probabilistic constraints
on loss and delay, but will be non-zero. Accordingly, to meet deadlines,
the transport must support partial reliability service, accepting that
it may not be able to deliver all data by its deadline.
Many real-time applications run over TCP today, and TCP does not offer a
partial reliability service. This results in occasional play-out stalls, 
when the transport blocks the application because a retransmission takes
too long. These stalls are one of the primary causes of poor user
experience in streaming applications, and are directly caused by the lack
of partial reliability in TCP. Missing one frame that has not been
delivered by its deadline is much less disruptive than a stall in play-out. 

Given deadlines and partial reliability, the next important transport
service is \emph{dependency management}. There is no point sending data
that cannot be used, because it depends on previous data that was lost. 
...complex trade-off, since you might want to send data that misses its 
   deadline, if it allows later data to be used. 

...following from this, we have the concept of application-level framing
   to make the best use of data, irrespective of losses. This implies that
   the transport provides a \emph{message oriented} service that respects
   ADU boundaries. 

...we note that many multimedia applications make use of multiple streams. 
   For example, audio and video are logically separate, etc.
   can be supported by opening multiple transport connections, but
   desirable to support a \emph{sub-stream} service to reduce overheads.

...finally, we note that \emph{congestion control} is important. 
   motivate: historically there has been a belief that real-time doesn't 
   do congestion control, needs an isochronous channel. 
   not practical for the Internet. 
   Also, experience has shown not necessary for many real-time applications.
   Yes, there are some that need constant bandwidth and cannot adapt, but
   many are adaptive. 
   Better user experience to adapt to fit the channel, rather than recover
   from loss after the channel discards packets that don't fit. 

We note that a connection-oriented transport is not a core requirement for
many real-time multimedia applications.  Indeed, flexibility to change the
destination of data within a call could be beneficial for applications that
support mobile users, or for some forms of multiparty session. However, to
support NAT traversal and to help dynamically manage firewall pinholes, it
is often desirable for the transport to be connection oriented. We find
these concerns outweigh the benefits of connectionless transport, and so
add a requirement for connection oriented service. 
Similarly, while not strictly needed by the applications, it is beneficial
if the transport provides a keep-alive service to refresh NAT and firewall
bindings if the application goes silent. 

Table \ref{tab:services} summarises the transport services required for
real-time multimedia applications.

\begin{table}
  \centering
  \begin{tabular}{ll}
    \toprule
      Transport Service     & Requirement \\
    \midrule
      Deadlines             & Core        \\
      Partial reliability   & Core        \\
      Dependencies          & Core        \\
      Message-oriented      & Core        \\
      Sub-streams           & Core        \\
      Congestion controlled & Core        \\
      Connection oriented   & Subsidiary  \\
      Keep-alive            & Subsidiary  \\
    \bottomrule
  \end{tabular}
  \caption{Transport services required for real-time multimedia}
  \label{tab:services}
\end{table}

Given a transport protocol that provides the above services, how could the
API between transport and application be structured? 

\todo{Stephen: outline the TCP Hollywood API, with text and a figure}

\begin{figure}
  \centering
  ...
  \caption{Outline transport API for real-time applications}
  \label{fig:api}
\end{figure}

It is to be noted that this API is not dissimilar to the PR-SCTP abstract
API, which provides \textit{timed reliability}, using a ``lifetime''
specified by the application. \todo{CSP: check this}

%==================================================================================================
\section{Innovation and Ossification}
\label{sec:ossification}

The Internet architecture, in principle, allows free innovation at the
transport layer, provided the underlying network (IP) layer is unchanged.  
Routers should inspect the source addresses of packets to perform network
ingress filtering \cite{RFC2827}, and the destination addresses to route
packets to the correction destination, but should not inspect their
contents. This is not, of course, how the real network operates. 

\todo{outline why this is not true in practice}

The implication of this reality is that it is difficult to deploy new 
transport protocols. The installed base of NATs, firewalls, and other
middleboxes is such that packets that do not look like TCP or UDP are
unlikely to pass the network. We may innovate all we like, provided the
transport of the future looks like TCP or UDP to middleboxes.\footnote{
  This is inconvenient, certainly, but is not necessarily a bad thing. 
  The Internet is critical infrastructure. It support emergency services, 
  healthcare applications, infrastructure components, financial services, 
  and so on, many of which are essential to the functioning of society. 
  Making changes to this type of infrastructure \emph{should} require 
  careful backwards compatibility.
}

UDP is the obvious base for future protocol development, since it provides
minimal additional services over the IP layer, allowing great flexibility
in innovation for protocols tunnelled on top. Provided middleboxes do not
inspect the payload too carefully, the only real cost to innovation, when
compared to a native transport protocol running over IP, is a few bytes of
additional header. Examples in this space include RTP \cite{RFC3550}, one
of the most widely deployed real-time transport protocols; the WebRTC Data
Channel \cite{}, which tunnels peer-to-peer SCTP associations over a DTLS
association over UDP; and QUIC \cite{}, which provides a modern alternative 
to TCP, implemented over UDP. 

Despite these advantages, UDP can be problematic as a substrate for new
protocol development. UDP traffic is blocked by some enterprise firewalls,
and some in the operations community have a strong distrust of UDP-based
protocols and applications \cite{draft-byrne-opsec-udp-advisory-00}. In
part this is due to ignorance. Outside specific niches, such as DNS, UDP
has not been widely used in enterprise environments, and hence is widely
misunderstood. Blocking the unknown is a rational response. In addition,
UDP traffic has been widely used as a component of distributed denial of
service (DDoS) attacks, leading some to install blanket blocks of UDP as 
a safety measure (blanket blocking, rather than the more targeted blocks 
used when TCP traffic is used in DDoS attacks, are justified using the
argument that UDP is not widely used).
These issues are slowly changing, as UDP-based applications penetrate the
enterprise consciousness, but not clear that UDP is universally available
(Google report 90-95\% of endpoints are reachable with QUIC
running over UDP \cite{roskind2013quic}, but it is not clear that the set
of hosts running their Chrome browser is representative of all Internet
environments). 

TCP is a more complex choice for innovation. It is a more sophisticated 
protocol than UDP, with complex headers, and a protocol state machine
that mandates much more behaviour and is widely understood, and policed,
by in-network middleboxes. This does not mean that TCP cannot evolve, or
form the basis for new transport services. Rather, it means that any
innovation or development must be done carefully, paying very careful
attention to backwards compatibility.

We identify a number of places where TCP can evolve with comparative
freedom. These include congestion control, the end-point API, and data
segmentation. If care is taken, there is also the possibility to change
the reliability semantic. 

The TCP congestion control algorithm is executed by the end points, and 
can be changed, provided the new version requires no new information to 
be exchanged. 
\todo{expand, and discuss how this evolution has occurred to date}
We note that, while standardised TCP congestion control has followed the
goal of maximising throughput at the expense of latency and variability,
this is not required by the protocol. TCP Vegas \cite{brakmo:1994:tcp-vegas}
is perhaps the best known approach that changes these constraints, with a
delay-based algorithm that reduces latency. It would also be possible to
implement alternatives that seek stability, or compatibility with the
dictates of a video codec, rather than the traditional ``TCP Friendly''
congestion control -- even if implemented within TCP.

The API that is exposed to applications using TCP is not visible to the
network, and can be changed. 
\todo{discuss how the API can be relaxed to allow out-of-order delivery}
\todo{discuss how the API can be modified to accept/delivery a sequence
      of messages, rather than a byte stream, and how with consistent
      segmentation at the sender and COBS framing, this can be efficient}

These changes could address many of the transport service needs we have for
real-time applications, but still leave a critical issue of how to improve
timing behaviour. Specifically, how to enable partial reliability for TCP,
after which it is possible to layer-on support for managing deadlines and 
dependencies.

%==================================================================================================
\section{Partial Reliability and TCP}
\label{sec:partial}

approach: 
- separate out sequence numbers in sent segments with sequence numbers
  visible to the application.
- COBS encode for message boundaries.
- retransmission have same segment sequence number, but different contents
  and application sequence numbers

Does it work?
- Initial deployment results from the UK
- Is there any more data that can be got quickly?

Any other surveys showing the same thing?

%==================================================================================================
\section{Realising Transport Services}
\label{sec:realising}

Assuming the above is true more generally, once wider measurements have
been conducted...

here is an abstract API for real-time transport services

we can clearly layer it above UDP: the services look a lot like PR-SCTP,
and experiences with the WebRTC data channel show that this can run over
UDP and be deployed in the wild.

these services are deployed over TCP now, but have an inconvenient API that
imposes lots of work on application developers, and with higher than desired
latency. 
TCP Hollywood offers a way to fix both issues.
Brief summary.
Obviously we need to change TCP congestion control too.

%==================================================================================================
\section{Related Work}
\label{sec:related}

% This should come near the end, and focussing on discussing how your work
% relates to that of others. Any relevant related work should have been
% cited already, so this is not a list of related work, it's a discussion
% of how that work relates.
%
% Why not put related work after the introduction? 1) because describing
% alternative approaches gets between the reader and your idea; and 2)
% because the reader knows nothing about the problem yet, so your
% (carefully trimmed) description of various technical trade-offs is
% absolutely incomprehensible.
% 
% When writing the related work:
%  - Give credit to others where it's due; this doesn't diminish the
%    credit you get from your paper. 
%  - Acknowledge weaknesses in your approach.
%  - Ensure related work is accurate and up-to-date



%==================================================================================================
\section{Conclusions}
\label{sec:conclusions}

to make effective use of the network, need to deploy new transport services
and protocols

seems likely that the appropriate long-term approach for doing this is to
repurpose UDP as a demultiplexing layer for higher-layer protocols. 

in the short term, we need to deal with networks that block UDP, and be
able to run over TCP.
our initial work shows that this is frequently possible, and works well
enough to offer benefit.

%==================================================================================================
\section{Acknowledgements}

% Acknowledge funding sources.

%==================================================================================================
\bibliographystyle{abbrv}
\bibliography{paper}
\end{document}
% vim: set ts=2 sw=2 tw=75 et ai:
