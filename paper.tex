\documentclass{sig-alternate-05-2015}
\usepackage[l2tabu,orthodox]{nag}
\usepackage[utf8x]{inputenc}       
\usepackage[british]{babel}        
\usepackage[babel=true]{microtype}
\usepackage{amsmath}
\usepackage[all]{onlyamsmath}
\usepackage{newtxtext}
\usepackage{newtxmath}
\usepackage{upquote}
\usepackage{graphicx}
\usepackage{url}
\usepackage[caption=false]{subfig}
\usepackage{booktabs}
\usepackage{bytefield}
\usepackage{listings}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{color}
\usepackage{balance}
\usepackage{tabularx}

\newcommand{\todo}[1]{\textbf{\textcolor{red}{To do -- #1}}}

%==================================================================================================
% The following information gets written into the PDF file information:
\pdfinfo{
  /Title        (Implementing Real-time Transport Services over an Ossified Network)
  /Author       (Stephen McQuistin, Colin Perkins, and Marwan Fayed)
  /Subject      (Real-time Transport Protocols)
  /Keywords     (Transport Services, TCP, TCP Hollywood)
  /CreationDate (D:20160516000000+01'00')
  /ModDate      (D:20160516000000+01'00')
  /Creator      (LaTeX)
  /Producer     (pdfTeX)
}
%==================================================================================================
\begin{document}
\title{Implementing Real-Time Transport Services over an Ossified Network}
\numberofauthors{3}
\author{
  \alignauthor
    Stephen McQuistin\\
    \affaddr{University of Glasgow, UK}\\
    \email{sm@smcquistin.uk}
  \alignauthor
    Colin Perkins\\
    \affaddr{University of Glasgow, UK}\\
    \email{csp@csperkins.org}
  \alignauthor
    Marwan Fayed\\
    \affaddr{University of Stirling, UK}\\
    \email{mmf@cs.stir.ac.uk}
}

\toappear{}
\maketitle
%==================================================================================================
\begin{abstract}

% Four sentences:
%  - State the problem
%  - Say why it's an interesting problem
%  - Say what your solution achieves
%  - Say what follows from your solution

Real-time applications require a set of transport services not currently
provided by widely-deployed transport protocols. Ossification prevents the
deployment of a novel protocols, restricting solutions to protocols using
either TCP or UDP as a substrate. We describe the transport services
required by real-time applications. We show that, in the short term (i.e.,
while UDP is blocked at current levels), TCP offers a feasible substrate
for providing these services. Over the longer term, protocols using UDP
may reduce the number of networks blocking UDP, enabling a shift towards
its use as a demultiplexing layer for novel transport protocols.

\end{abstract}
%==================================================================================================
\begin{CCSXML}
  <ccs2012>
    <concept>
      <concept_id>10003033.10003039.10003040</concept_id>
      <concept_desc>Networks~Network protocol design</concept_desc>
      <concept_significance>500</concept_significance>
    </concept>
    <concept>
      <concept_id>10003033.10003039.10003048</concept_id>
      <concept_desc>Networks~Transport protocols</concept_desc>
      <concept_significance>500</concept_significance>
    </concept>
  </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Networks~Network protocol design}
\ccsdesc[500]{Networks~Transport protocols}

\printccsdesc

\keywords{Transport protocols; real-time multimedia applications}
%==================================================================================================
\section{Introduction}

% A good paper introduction is fairly formulaic. If you follow a simple set
% of rules, you can write a very good introduction. The following outline can
% be varied. For example, you can use two paragraphs instead of one, or you
% can place more emphasis on one aspect of the intro than another. But in all
% cases, all of the points below need to be covered in an introduction, and
% in most papers, you don't need to cover anything more in an introduction.
%
% Paragraph 1: Motivation. At a high level, what is the problem area you
% are working in and why is it important? It is important to set the larger
% context here. Why is the problem of interest and importance to the larger
% community?

Real-time applications are increasingly important in the Internet. 
We want to make it easier to write these applications, while improving
the quality of experience for users of those applications by lowering
latency and increasing robustness. 
In this, we are challenged by the limitations of the standard Internet 
transport protocols, and by the ossified nature of the network, which makes
it increasingly difficult to deploy new transports. 

% Paragraph 2: What is the specific problem considered in this paper? This
% paragraph narrows down the topic area of the paper. In the first
% paragraph you have established general context and importance. Here you
% establish specific context and background.

In practice, the only protocols that can be widely used in the Internet are
TCP and UDP. Other protocols are blocked by firewalls and other middleboxes.  
TCP provides sophisticated congestion control, coupled with a reliable,
ordered, byte stream API. These are suitable for many applications, but are
not necessarily appropriate for real-time traffic.  UDP exposes the best-effort 
IP packet delivery service, offering flexibility to develop new protocols,
but at the cost of requiring completely new protocol mechanisms to be
defined. Both protocols are usable for real-time applications, but neither
really provides the right services and API.  This forces each application
to re-invent mechanisms that should be provided by the transport, increasing 
costs and complexity, raising barriers to innovation.

% Paragraph 3: "In this paper, we show that...". This is the key paragraph
% in the introduction - you summarize, in one paragraph, what are the main
% contributions of your paper, given the context established in paragraphs 
% 1 and 2. What's the general approach taken? Why are the specific results
% significant? The story is not what you did, but rather:
%  - what you show, new ideas, new insights
%  - why interesting, important?
% State your contributions: these drive the entire paper.  Contributions
% should be refutable claims, not vague generic statements.

In this paper we discuss the appropriate set of transport services and APIs
for real-time applications.
We demonstrate that it is possible to realise these services and APIs
in the context of both TCP and UDP, despite the limitations imposed by the
legacy protocols, middleboxes, and ossification of the network. 
We present initial results to show that, despite the observed ossification,
the network has the flexibility to deploy new transport protocols, if care
is taken to reinterpret layer boundaries and deploy those new transports in
the context of TCP and UDP.

% Paragraph 4: What are the differences between your work, and what others
% have done? Keep this at a high level, as you can refer to future sections
% where specific details and differences will be given, but it is important
% for the reader to know what is new about this work compared to other work
% in the area.

Our contributions are to identify the needs of real-time applications, and
the appropriate transport services and APIs to support those needs; 
to illustrate how those transport services can be realised on the current
Internet, in the context of UDP and TCP deployments; and 
to present some initial measurement results to show that the mechanisms we
propose ought to be usable in the public Internet. 

% Paragraph 5: "We structure the remainder of this paper as follows." Give
% the reader a road-map for the rest of the paper. Try to avoid redundant
% phrasing, "In Section 2, In section 3, ..., In Section 4, ... ", etc.

We begin, in Section \ref{sec:services} by discussing transport services 
for real-time applications, and outlining the common conceptual API that
those applications use. 
This is followed, in Section \ref{sec:ossification}, by a review of the
deployment considerations for new protocols, caused by ossification of
the network, with Section \ref{sec:partial} considering, in particular, how
TCP reliability semantics can evolve within the constraints of the deployed
infrastructure.
Section \ref{sec:realising} outlines how the transport services we have
identified can be realised in practical networks.
Finally, Section \ref{sec:related} discusses related work, and Section
\ref{sec:conclusions} concludes.

%==================================================================================================
\section{Real-time Transport Services}
\label{sec:services}

In the IETF, the Transport Services (TAPS) working group is chartered to 
(1) develop a taxonomy of \emph{transport services}, that is, to identify the
features that comprise, and can be combined to form, complete transport
protocols; and (2) to develop an abstract API for applications to request
desirable services, allowing the system to select an appropriate transport
protocol based on application needs. It is hoped that this will loosen the
coupling between application and transport, so enabling deployment of new 
transport protocols.

%--------------------------------------------------------------------------------------------------
\subsection{Transport Services}

The work in TAPS is valuable, because it gives us a vocabulary for
discussing the components of transport protocols.  We can then use that
vocabulary when discussing the needs of real-time applications, and the
protocols needed to support those needs.

The essential feature of real-time applications is clearly timing. That is,
since these applications convey real-time data, they all have some concept
of a \emph{deadline} by which that data must be presented, after which it
becomes useless. 
The deadline might be short or long. Interactive applications, such as
telephony, video conferencing, or telepresence, require low end-to-end
latency, with the deadline for presenting the media (playing the audio,
displaying the video frame) being tens, or perhaps low hundreds, of
milliseconds after it was captured. Non-interactive applications, such as
broadcast TV, may have deadlines in the order of seconds, or even tens of
seconds for on-demand programming. 
The deadlines in many networked multimedia applications are unusual when
compared to other real-time systems. They are simultaneously flexible and
strict: flexible in that the exact value of the deadline is typically not
important, provided it is of the right order-of-magnitude for the
application, but strict in that any particular deadline provides a hard
cut-off, after which the data is useless. 

The presence of deadlines, in a network that offers only a best-effort
packet delivery service, implies that the transport must provide
\emph{partial reliability}.
The network has non-zero probability of losing any particular packet. 
If forward error correction is used to repair loss, this implies there is
always some probability that a particular packet will be non-recoverable.
If retransmission is used to recover from losses, there is the potential 
for unbounded delay, since any retransmission may itself be lost. 
These probabilities can be estimated, to give probabilistic constraints
on loss and delay, but will be non-zero. Accordingly, to meet deadlines,
the transport must support partial reliability service, accepting that
it may not be able to deliver all data by its deadline.
Many real-time applications run over TCP today, and TCP does not offer a
partial reliability service. This results in occasional play-out stalls, 
when the transport blocks the application because a retransmission takes
too long. These stalls are one of the primary causes of poor user
experience in streaming applications, and are directly caused by the lack
of partial reliability in TCP. Missing one frame that has not been
delivered by its deadline is much less disruptive than a stall in play-out. 

Given deadlines and partial reliability, the next important transport
service is \emph{dependency management}. There is no point in sending data
that cannot be used because it depends on previous data that was not
received. Providing this service is complicated by the two ways in which
data can be \emph{useful} to applications: it may itself by played out, or
it may be needed as part of the application's decoding chain. For example,
an I frame provides utility both in being played out, and in allowing for
subsequent P and B frames. As a result, dependency information may result
in deadline information being overruled: data may be sent even if it cannot
be played out, if it is necessary for the decoding of other data.

Providing partial reliability, through deadlines and dependencies, requires
the use of application-level framing \cite{clark:1990:architecture} to
make the best use of payload data, irrespective of packet loss. At the
transport layer, this implies that we provide a \emph{message oriented}
service, that maintains ADU boundaries.

Many multimedia applications make use of multiple data flows. For example,
a simple IPTV application will maintain separate audio and video flows.
These could be sent across multiple transport-layer connections, but
overheads can be reduced by multiplexing these flows on a single
connection. A \emph{sub-stream} service allows this.

We note that \emph{congestion control} is important. Clearly, the historic
belief that real-time applications require an isochronous channel, and
cannot be subjected to congestion control, is not practical on the
Internet. Further, while there is a number of applications that are not
adaptive (and require constant bandwidth), an increasing number are
adaptive, and would better serve users by adapting to the available
bandwidth.

We note that a connection-oriented transport is not a core requirement for
many real-time multimedia applications.  Indeed, flexibility to change the
destination of data within a call could be beneficial for applications that
support mobile users, or for some forms of multiparty session. However, to
support NAT traversal and to help dynamically manage firewall pinholes, it
is often desirable for the transport to be connection oriented. We find
these concerns outweigh the benefits of connectionless transport, and so
add a requirement for connection oriented service. 
Similarly, while not strictly needed by the applications, it is beneficial
if the transport provides a keep-alive service to refresh NAT and firewall
bindings if the application goes silent. 

Table \ref{tab:services} summarises the transport services required for
real-time multimedia applications. 

%--------------------------------------------------------------------------------------------------
\subsection{Abstract API}

Given the set of transport services outlined in Table \ref{tab:services}, 
we sketch an abstract API in  Table \ref{tab:api}. The primitives divide
into four categories:

\begin{itemize}
  \item Hosts setup and tear-down sockets using the \texttt{socket()}
    and \texttt{close()} functions, as in the standard Berkeley sockets
    API. 

  \item The connection primitives are the same as those of TCP sockets.
    Servers \texttt{bind()} to a particular address and port, then
    \texttt{listen()} for and \texttt{accept()} incoming connections.
    Clients \texttt{connect()} to a server.

   \item Once the connection is established, the receiver application
     indicates the media play-out delay it is using, in milliseconds, via
     the \texttt{set\_po\_delay()} call. This specifies the time that the
     application will buffer data, to compensate for network timing jitter,
     before it is rendered to the user. The play-out delay is fed back to
     the sender host, for use as part of the media deadline estimation. 
    
  \item Finally, message-oriented data transmission is exposed by the
    \texttt{send\_message()} and \texttt{recv\_message()} functions.  
    These expose a partially reliable message delivery service to the
    application, framing data such that either a complete message is
    delivered, or it is lost in its entirety. 

    The \texttt{send\_message()} call takes four additional parameters
    compared to the standard Berkeley Sockets API. These are 1) a message
    sequence number, that can be used to re-order messages and detect 
    message loss; 2) a relative deadline, which is combined with an
    estimate of the current round-trip-time, and the time that the message
    has spent in the sending buffer, to determine if a message will arrive
    in time to be played-out; 3) the sequence number of any message on
    which this depends, for example the sequence number of a video I-frame
    on which a P-frame is predicted; and 4) a sub-stream identifier, used,
    for example, to differentiate audio, video, sub-title, control, and
    repair streams.

    The \texttt{recv\_message()} call returns the sequence number,
    dependency information, and sub-stream identifier along with any
    received message, allowing the receiver to direct it to the correct
    decoding queue. 

    \todo{relate this to the transport services described earlier}

\end{itemize}

    
A message that won't arrive within its lifetime is considered to have
\emph{expired}. Applications specify the application-level sequence number
of a message they depend on (\texttt{depends\_on}). If the message depends
on a message that has expired, then it too is considered to have expired.
The partial reliability service follows from the deadline and dependency
services: messages will be reliably transmitted until they expire.


\begin{table}
  \centering
  \begin{tabular}{ll}
    \toprule
      Transport Service     & Requirement \\
    \midrule
      Deadlines             & Core        \\
      Partial reliability   & Core        \\
      Dependencies          & Core        \\
      Message-oriented      & Core        \\
      Sub-streams           & Core        \\
      Congestion controlled & Core        \\
      Connection oriented   & Subsidiary  \\
      Keep-alive            & Subsidiary  \\
    \bottomrule
  \end{tabular}
  \caption{Transport services required for real-time multimedia}
  \label{tab:services}
\end{table}

\begin{table*}
  \centering
  \begin{tabularx}{\textwidth}{llll}
    \toprule
      Transport Service            & Function & Parameters                                     & Return Value \\
    \midrule
                                   & \texttt{socket}         
                                              & \texttt{af} -- Address family                  & Socket descriptor \\
                                   &          & \texttt{st} -- Socket type & \\
                                   & \texttt{close}          
                                              & \texttt{sd} -- Socket descriptor               & 0 (success), -1 (error) \\
    \midrule
      Connection oriented          & \texttt{bind}           
                                              & \texttt{sd} -- Socket descriptor               & 0 (success), -1 (error) \\
                                   &          & \texttt{addr} -- Address to bind to & \\
                                   &          & \texttt{addrlen} -- Length of \texttt{addr} & \\
                                   & \texttt{listen}         
                                              & \texttt{sd} -- Socket descriptor               & 0 (success), -1 (error) \\
                                   & \texttt{accept}        
                                              & \texttt{sd} -- Listening socket descriptor     & Connection socket descriptor \\
                                   &          & \texttt{addr} -- Address of peer & \\
                                   &          & \texttt{addrlen} -- Length of \texttt{addr} & \\
                                   & \texttt{connect}        
                                              & \texttt{addr} -- Address to connect to         & 0 (success), -1 (error) \\
                                   &          & \texttt{addrlen} -- Length of \texttt{addr} & \\
    \midrule
      Deadlines                    & \texttt{set\_po\_delay} 
                                              & \texttt{delay} -- Playout delay (in ms)        & 0 (success), -1 (error) \\
    \midrule
      Message oriented             & \texttt{send\_message}  
                                              & \texttt{sd} -- Socket descriptor               & Number of bytes sent \\
                                   &          & \texttt{buf} -- Message data & \\
                                   &          & \texttt{len} -- Length of message data & \\
                                   &          & \texttt{seq\_num} -- Sequence number & \\
      Deadlines                    &          & \texttt{deadline} -- Relative deadline of message (in ms) & \\ 
      Dependencies                 &          & \texttt{depends\_on} -- \texttt{seq\_num} of dependency & \\
      Sub-streams                  &          & \texttt{substream} -- Substream identifier & \\
                                   & \texttt{recv\_message}  
                                              & \texttt{sd} -- Socket descriptor               & Number of bytes received \\
                                   &          & \texttt{buf} -- Buffer for message data & \\
                                   &          & \texttt{len} -- Size of \texttt{buf} & \\
      Sub-streams                  &          & \texttt{substream} -- Substream identifier & \\
                                   &          & \todo{return value, rather than param?} & \\
    \bottomrule
  \end{tabularx}
  \caption{Outline transport API for real-time applications. Return values
  shown are for successful calls; in all cases, -1 is returned in the event
  of an error}
  \label{tab:api}
\end{table*}

It is to be noted that this API is not dissimilar to the PR-SCTP abstract
API, which provides \textit{timed reliability}, using a ``lifetime''
specified by the application. \todo{CSP: check this}

%==================================================================================================
\section{Innovation and Ossification}
\label{sec:ossification}

The Internet architecture, in principle, allows free innovation at the
transport layer, provided the underlying network (IP) layer is unchanged.  
Routers should inspect the source addresses of packets to perform network
ingress filtering \cite{rfc:2827}, and the destination addresses to route
packets to the correction destination, but should not inspect their
contents. This is not, of course, how the real network operates. 

\todo{outline why this is not true in practice}

The implication of this reality is that it is difficult to deploy new 
transport protocols. The installed base of NATs, firewalls, and other
middleboxes is such that packets that do not look like TCP or UDP are
unlikely to pass the network. We may innovate all we like, provided the
transport of the future looks like TCP or UDP to middleboxes.\footnote{
  This is inconvenient, certainly, but is not necessarily a bad thing. 
  The Internet is critical infrastructure. It support emergency services, 
  healthcare applications, infrastructure components, financial services, 
  and so on, many of which are essential to the functioning of society. 
  Making changes to this type of infrastructure \emph{should} require 
  careful backwards compatibility \cite{mcquistin:2015:reinterpreting}.
}

UDP is the obvious base for future protocol development, since it provides
minimal additional services over the IP layer, allowing great flexibility
in innovation for protocols tunnelled on top. Provided middleboxes do not
inspect the payload too carefully, the only real cost to innovation, when
compared to a native transport protocol running over IP, is a few bytes of
additional header. Examples in this space include RTP \cite{rfc:3550}, one
of the most widely deployed real-time transport protocols; the WebRTC Data
Channel \cite{draft-ietf-rtcweb-data-channel-13}, which tunnels
peer-to-peer SCTP associations over a DTLS association over UDP; and QUIC
\cite{draft-tsvwg-quic-protocol-02}, which provides a modern alternative 
to TCP, implemented over UDP. 

Despite these advantages, UDP can be problematic as a substrate for new
protocol development. UDP traffic is blocked by some enterprise firewalls,
and some in the operations community have a strong distrust of UDP-based
protocols and applications \cite{draft-byrne-opsec-udp-advisory-00}. In
part this is due to ignorance. Outside specific niches, such as DNS, UDP
has not been widely used in enterprise environments, and hence is widely
misunderstood. Blocking the unknown is a rational response. In addition,
UDP traffic has been widely used as a component of distributed denial of
service (DDoS) attacks, leading some to install blanket blocks of UDP as 
a safety measure (blanket blocking, rather than the more targeted blocks 
used when TCP traffic is used in DDoS attacks, are justified using the
argument that UDP is not widely used).
These issues are slowly changing, as UDP-based applications penetrate the
enterprise consciousness, but not clear that UDP is universally available
(Google report 90-95\% of endpoints are reachable with QUIC
running over UDP \cite{roskind2013quic}, but it is not clear that the set
of hosts running their Chrome browser is representative of all Internet
environments). 

\todo{Other motivation for using TCP: HTTP-based streaming protocols}

TCP is a more complex choice for innovation. It is a more sophisticated 
protocol than UDP, with complex headers, and a protocol state machine
that mandates much more behaviour and is widely understood, and policed,
by in-network middleboxes. This does not mean that TCP cannot evolve, or
form the basis for new transport services. Rather, it means that any
innovation or development must be done carefully, paying very careful
attention to backwards compatibility.

We identify a number of places where TCP can evolve with comparative
freedom. These include congestion control, the end-point API, and data
segmentation. If care is taken, there is also the possibility to change
the reliability semantic. 

The TCP congestion control algorithm is executed by the end points, and 
can be changed, provided the new version requires no new information to 
be exchanged. 
\todo{expand, and discuss how this evolution has occurred to date}
We note that, while standardised TCP congestion control has followed the
goal of maximising throughput at the expense of latency and variability,
this is not required by the protocol. TCP Vegas \cite{brakmo:1994:tcp-vegas}
is perhaps the best known approach that changes these constraints, with a
delay-based algorithm that reduces latency. It would also be possible to
implement alternatives that seek stability, or compatibility with the
dictates of a video codec, rather than the traditional ``TCP Friendly''
congestion control -- even if implemented within TCP.

The API that is exposed to applications using TCP is not visible to the
network, and can be changed. Relaxing the API to enable the out-of-order
delivery of segments is trivial: segments are delivered to the application
in the order that they arrive, with their TCP sequence attached. The TCP
sequence number can be passed to the application using the existing
Berkeley sockets API, either with the received data, or using 
\texttt{getsockopt()}. Out-of-order delivery is not useful when using a 
byte-stream abstraction, and so the API should be further modified to
provide a message-oriented abstraction. The Berkeley sockets API already
supports such an abstraction for datagram protocols.

\todo{discuss how the API can be modified to accept/delivery a sequence
      of messages, rather than a byte stream, and how with consistent
      segmentation at the sender and COBS framing, this can be efficient}

These changes could address many of the transport service needs we have for
real-time applications, but still leave a critical issue of how to improve
timing behaviour. Specifically, how to enable partial reliability for TCP,
after which it is possible to layer-on support for managing deadlines and 
dependencies.

%==================================================================================================
\section{Partial Reliability and TCP}
\label{sec:partial}

Partial reliability (i.e., reliability conditional on timing and dependency
information) can be implemented by relaxing TCP's reliability guarantee.
The implication of this is that we need to offer a message-oriented
abstraction to applications. If the arrival of a segment cannot be
guaranteed, then it is not possible to offer a byte stream abstraction.

To offer a message-oriented abstraction, the boundaries between each
message must be maintained between sender and receiver. This means that a
framing mechanism is required: it is not sufficient to send each message in
a single segment, as this mapping will not necessarily be maintained by the
network. A framing marker is added to the start and end of each message
before transmission. An encoding algorithm is used to escape all occurrences
of the framing marker within the message data. This process does not impact
on the data that can be sent or received by applications.

In order to maintain compatibility with middleboxes, offering partial
reliability requires using \emph{inconsistent retransmissions}. This means
that the mapping between message data and TCP sequence numbers is no longer
static: a given TCP sequence number may be relate to different messages at
different times. Therefore, an application-level sequence number is
required to allow messages to be uniquely identified.

When a TCP segment is to be retransmitted, the current mapping between its
sequence number and application-level sequence numbers is used to determine
which messages within the segment are to be retransmitted. A liveness check
is performed on these messages, to determine that (i) the message will
arrive on time to be played out; and (ii) the message does not depend on an
expired message. For (i), we combine the time that the message has spent in
a sending queue, with an estimate of the round-trip time and the current
play-out delay. This is then compared against the lifetime of the message,
as expressed by the application. For (ii), we maintain metadata about
sequence numbers that have expired, and check this metadata for the
dependency expressed by the application.

This mechanism -- inconsistent retransmissions -- is visible to middleboxes
on the network that are performing payload inspection. These middleboxes
may interpret this behaviour relating to an attack. For example, a
man-on-the-side attack exhibits similar behaviour, where a malicious host
is injecting data into an existing TCP flow. As a result, our connection
may be disrupted. Honda \emph{et al}.\ \cite{honda:2011:extend-tcp} conducted
experiments across 135 paths on the Internet, to determine support for
inconsistent retransmissions. They observed that the majority of paths
delivered inconsistent retransmissions successfully. On Port 80 (HTTP), the
original segment was delivered on 7\% of paths tested. Only one connection
reset was observed. 

We conducted further deployment experiments using
inconsistent retransmissions \cite{mcquistin2016hollywood}, testing all 
major UK providers. We found that 100\% of tested fixed-line networks
delivered inconsistent retransmissions successfully. However, the delivery
of the original segment is common on cellular networks, with only 25\% of
tested networks delivering inconsistent retransmissions successfully and
reliably. The behaviour observed when evaluating cellular networks was
consistent with that of a transparent, split-connection TCP cache. Segments
were lost, but were retransmitted (with the IP address of the sender) by a
middlebox in the network. It is likely that these caches are deployed close
to the wireless link, given its relatively high rate of non-congestive
loss.

These deployment experiments suggest that our protocol should be
flexible: inconsistent retransmissions may not be delivered, and we should
handle reception of the original segment. If the protocol detects that
inconsistent retransmissions are not being delivered, then the mechanism
can be disabled for the connection. Further, if a connection reset occurs,
then the connection should be retried with the mechanism disabled.

The use of inconsistent retransmissions may interact negatively with
caching and resegmenting middleboxes, resulting in the corruption of
messages between sender and receiver. A message may be formed from the
original message, and an inconsistent retransmission, given how the
mechanism uses the TCP sequence space. To protect against this, a checksum
must be attached to each message, to allow the receiver to verify its
integrity. The role of a checksum may also be fulfilled by using a secure
transport protocol, such as DTLS \cite{rfc:6347}.

%==================================================================================================
\section{Realising Transport Services}
\label{sec:realising}

While further measurement studies are required to confirm the ability to
deploy wire-visible changes to TCP (such as inconsistent retransmissions),
we have shown that we can provide all of the transport services needed by
real-time applications, using either TCP or UDP. 

Evidence that these services can be deployed above UDP exists in the form
of the WebRTC data channel \cite{draft-ietf-rtcweb-data-channel-13} and
QUIC protocol \cite{draft-tsvwg-quic-protocol-02}.  
The former is a peer-to-peer protocol, comprising an SCTP association
running over DTLS, itself running over a UDP flow negotiated via an SDP
\cite{RFC4566} offer/answer exchange \cite{RFC3264} as part of a WebRTC
session \cite{jennings:2013:rtcweb} (the WebRTC media channel uses RTP
running over UDP also, further showing the utility of UDP-based data). 
This has been deployed in popular web browsers, with global deployment, and
demonstrated to be effective.  The latter is implemented by Google in their
Chrome browser, and used as an alternative to TCP has a significant
fraction of web traffic downloads from their domain.

% The API shown in Table \ref{tab:api} is largely similar to that PR-SCTP,
% which has seen real-world deployments within the WebRTC protocol,
% demonstrating that we can layer these services above UDP.

Deployments using UDP are popular, and work well. However, as described in
Section \ref{sec:ossification}, there are also reasons for providing these 
services over TCP, since there are a significant fraction of networks that
block UDP traffic. It is clearly possible to run real-time traffic over
TCP, as demonstrated by applications such as NetFlix or the BBC iPlayer
that comprise the majority of Internet traffic. However, TCP has a
inconvenient API that imposes lots of work on application developers, and
introduces higher than desired latency. We have shown how to address these
issues, and provide the full set of transport services we propose in
Section \ref{sec:services} in previous work, with our TCP Hollywood
proposal \cite{mcquistin2016hollywood}.

\begin{figure}[t]
 \centering
 \includegraphics[scale=0.965]{figures/tcp-hollywood.pdf}
 \caption{TCP Hollywood architecture}
\label{diagram:tcp-hollywood}
\end{figure}

The architecture of TCP Hollywood is shown in
Figure \ref{diagram:tcp-hollywood}. TCP Hollywood provides all of the
services described in Section \ref{sec:services}, with functionality split
across an intermediary layer (in user-space), and a set of modifications to
the kernel. The intermediary layer is responsible for providing the
message-oriented abstraction, and exposing the API for partial reliability.
The kernel modifications implement the deadline and dependency services,
as well as enabling out-of-order delivery of incoming segments. This split
allows applications to use a single API, whether or not the kernel
modifications are available. TCP Hollywood inherits standard TCP's
congestion control mechanism. Clearly, this loss-based mechanism is not
suitable for real-time applications, and a delay-based algorithm should
be adopted.

\todo{Stephen: give more detail, and expand this to a whole column}

\todo{discuss how we need to change TCP congestion control}

Taken together, the wide experiences with the WebRTC Data Channel and QUIC
demonstrate that the transport services necessary to support real-time
traffic could be deployed running over UDP. Our work prototyping the TCP
Hollywood protocol, and earlier measurements by Honda \emph{et al}.\
\cite{honda:2011:extend-tcp} also suggest that deployment over TCP is
possible.

The challenge for the future is in combining such techniques below a common
API, so that an application can transparently switch between UDP-based and
TCP-based transport, depending on what is supported by the underlying
network. This is the promise of the TAPS API, that we have shown ought to
be feasible for real-time applications.

%==================================================================================================
\section{Related Work}
\label{sec:related}

% This should come near the end, and focussing on discussing how your work
% relates to that of others. Any relevant related work should have been
% cited already, so this is not a list of related work, it's a discussion
% of how that work relates.
%
% Why not put related work after the introduction? 1) because describing
% alternative approaches gets between the reader and your idea; and 2)
% because the reader knows nothing about the problem yet, so your
% (carefully trimmed) description of various technical trade-offs is
% absolutely incomprehensible.
% 
% When writing the related work:
%  - Give credit to others where it's due; this doesn't diminish the
%    credit you get from your paper. 
%  - Acknowledge weaknesses in your approach.
%  - Ensure related work is accurate and up-to-date

The Minion protocol suite \cite{nowlan:2012:minion} includes uTCP, a
protocol that uses TCP as a substrate to provide an unordered,
message-oriented service to applications. While this enables many of
the transport services described in Section \ref{sec:services}, support for
partial reliability, deadlines, and dependencies is not provided. 
Time-Lined TCP (TLTCP) \cite{mukherjee:2000:timelines} similarly provides a
message-oriented service, but allows applications to attach a time-line
to messages. Messages are (re-)transmitted asunder standard TCP within
their time-line, after which they are discarded. The mechanism by which
this service is provided (i.e., the introduction of gaps in the sequence
space) reduces deployability.

\todo{QUIC}

\todo{SPUD}

\todo{WebRTC data channel - SCTP over UDP}

\todo{RFC6773 - DCCP over UDP}


%==================================================================================================
\section{Conclusions}
\label{sec:conclusions}

to make effective use of the network, need to deploy new transport services
and protocols

seems likely that the appropriate long-term approach for doing this is to
repurpose UDP as a demultiplexing layer for higher-layer protocols. 

in the short term, we need to deal with networks that block UDP, and be
able to run over TCP.
our initial work shows that this is frequently possible, and works well
enough to offer benefit.

%==================================================================================================
%\section{Acknowledgements}

% Acknowledge funding sources.

%==================================================================================================
\bibliographystyle{abbrv}
\bibliography{paper}
\end{document}
% vim: set ts=2 sw=2 tw=75 et ai:
